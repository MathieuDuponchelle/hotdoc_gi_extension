#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright © 2016 Mathieu Duponchelle <mathieu.duponchelle@opencreed.com>
# Copyright © 2016 Collabora Ltd
#
# This library is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2.1 of the License, or (at your option)
# any later version.
#
# This library is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
# details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import urllib
import argparse
import urlparse
import shutil
import subprocess

from copy import deepcopy

import ipdb

import yaml

from lxml import etree

from hotdoc.utils.patcher import Patcher
from hotdoc.utils.utils import OrderedSet
from hotdoc.core.symbols import *
from hotdoc.core.doc_repo import DocRepo
from hotdoc.core.doc_database import DocDatabase
from hotdoc_gi_extension.gi_extension import GIExtension

# Some useful symbols

MD_OUTPUT_PATH = 'hotdoc_markdown'

def which(program):
    import os
    def is_exe(fpath):
        return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

    fpath, fname = os.path.split(program)
    if fpath:
        if is_exe(program):
            return program
    else:
        for path in os.environ["PATH"].split(os.pathsep):
            path = path.strip('"')
            exe_file = os.path.join(path, program)
            if is_exe(exe_file):
                return exe_file

    return None

def require_program(program):
    if which(program) is None:
        print "Checking for %s: no" % program
        print "Please install %s" % program
        sys.exit(1)
    print "Checking for %s: yes" % program

def require_path(path):
    if not os.path.isfile(path):
        print "%s is not a valid path" % path
        print "Please correct it, exiting"
        sys.exit(1)

def check_pandoc():
    require_program('pandoc')
    oformats = ['commonmark', 'markdown_github', 'markdown']
    pandoc_help = subprocess.check_output(['pandoc', '-h'])

    print "Checking pandoc output formats in preference order"

    found = False

    for oformat in oformats:
        if oformat in pandoc_help:
            res = 'yes'
            found = True
        else:
            res = 'no'

        print "Checking pandoc's '%s' output format: %s" % (oformat, res)

        if found:
            break

    if not found:
        print "No format found, please install a newer pandoc"
        sys.exit(1)

    return oformat

def stripped_basename(path):
    bname = os.path.basename(path)
    return os.path.splitext(bname)[0]

def quiet_call(cmd):
    with open(os.devnull, 'w') as shutup:
        return_code = subprocess.call(cmd, stdout=shutup, stderr=shutup)
    return return_code

def is_version_controlled(dir_, path):
    cwd = os.getcwd()
    os.chdir(dir_)
    result = quiet_call(['git', 'ls-files', '--error-unmatch', path])
    os.chdir(cwd)
    return result == 0

MD_FORMAT = check_pandoc()
require_program('git')


class DocRepoMonitor(object):
    def __init__(self):
        self.section_comments = {}

    def build(self, args):
        DocDatabase.comment_added_signal.connect(self.__comment_added)
        self.doc_repo = DocRepo()
        self.doc_repo.setup(args)
        self.naive_pages = {}
        for name, page in self.doc_repo.doc_tree.pages.items():
            bname = os.path.basename(name)

            if not bname.startswith('gen-'):
                continue

            if bname == 'gen-gi-extension-index.markdown':
                continue

            bname = bname[4:]
            stripped = os.path.splitext(bname)[0]
            self.naive_pages[stripped] = page

    def __comment_added(self, doc_db, comment):
        if comment.name.startswith('SECTION:'):
            self.section_comments[comment.name] = comment

def db_to_md (content):
    with open ("tmpfile", 'w') as f:
        f.write (content)
    cmd = ['pandoc', '-s', '-f', 'docbook', '-t', MD_FORMAT]
    cmd.append ("tmpfile")
    converted = subprocess.check_output (cmd)
    os.unlink ('tmpfile')
    return converted

class DTDResolver(etree.Resolver):
    def __init__(self, paths):
        self.urls = {}
        for p in paths or []:
            for f in os.listdir(p):
                url = os.path.join(p, f)
                if os.path.isfile(url):
                    self.urls[f] = url

    def resolve(self, url, id, context):
        comps = urlparse.urlparse(url)
        if not comps.scheme:
            bname = os.path.basename(url)
            my_url = self.urls.get(bname)
            if my_url:
                return self.resolve_filename(my_url, context)
        return etree.Resolver.resolve(self, url, id, context)

def get_free_md_path(md_paths, name):
    path = os.path.join (MD_OUTPUT_PATH, name + ".markdown")

    n = 0
    while path in md_paths:
        n += 1
        path = os.path.join (MD_OUTPUT_PATH, name + '_' * n + ".markdown")

    md_paths[name] = path

    return path

def replace_with_link(node, md_name, label):
    parent = node.getparent()
    new_node = etree.Element('sect3')
    title = etree.Element('title')
    link = etree.Element('ulink', attrib={'url': md_name})
    link.text = label
    title.append(link)
    new_node.append(title)
    parent.replace(node, new_node)

def dump_gi_index(standalones, md_paths):
    md_content = '# GObject-introspected API Reference\n\n'

    parent = standalones[0].getparent()
    replace_with_link(standalones[0], 'gobject-api',
        'GObject-introspected API Reference')

    if len(standalones) == 1:
        db_content = etree.tostring(standalones[0])
        md_content += db_to_md (db_content)
    else:
        sectnum = 0
        for standalone in standalones:
            parent = standalone.getparent()
            if parent is not None:
                parent.remove(standalone)

            tnode = standalone.find('./title')
            if tnode is not None:
                title = "".join([x for x in tnode.itertext()])
            else:
                sectnum += 1
                title = "Section %d" % sectnum
            db_content = etree.tostring(standalone)
            href = title
            md_path = urllib.unquote(get_free_md_path(md_paths, href))
            sub_md_content = db_to_md (db_content)
            print "Writing %s " % md_path, "there"
            with open(md_path, 'w') as f:
                f.write(sub_md_content)
            md_content += '### [%s](%s)\n\n' % (
                title, urllib.quote(os.path.basename(md_path)))

    md_path = os.path.join(MD_OUTPUT_PATH, 'gi-index.markdown')
    with open(md_path, 'w') as f:
        f.write (md_content)

NSMAP = {}

def translate_docbook(filename, resolver, md_paths, new_name):
    with open(filename, 'r') as _:
        xincluded = _.read()

    subpages = {}

    dir_ = os.path.dirname(filename)

    parser = etree.XMLParser(load_dtd=True, recover=True)
    parser.resolvers.add(resolver)
    root = etree.parse(filename, parser=parser).getroot()

    NSMAP.update(root.nsmap)

    for error in parser.error_log:
        print error

    if parser.error_log:
        print "Continuing despite the error"

    includes = root.findall('.//{%s}include' % NSMAP['xi'])

    standalones = OrderedSet()

    for node in includes:
        href = node.attrib.get('href')
        if href is None:
            continue

        bname = stripped_basename(href)
        parent = node.getparent()

        if bname == 'annotation-glossary' or bname.startswith('api-index') or \
                bname.startswith('tree_index'):
            parent.remove(node)
            continue

        md_path = get_free_md_path(md_paths, bname)
        replace_with_link(node, os.path.basename(md_path), bname)

        if is_version_controlled(dir_, href):
            subpages[bname] = os.path.join(dir_, href)
        elif new_name == 'index':
            grandparent = parent.getparent()
            already_added = False
            while grandparent is not None and grandparent not in standalones:
                grandparent = grandparent.getparent()

            if not already_added:
                standalones.add(parent)

    metadict = {}

    for node in root.findall('.//refmeta'):
        for c in node:
            meta =  "".join([x for x in c.itertext()])
            metadict[c.tag] = meta
        parent = node.getparent()
        parent.remove(node)

    if metadict:
        print "Writing", new_name + '.yaml'
        with open (os.path.join (MD_OUTPUT_PATH, new_name + ".yaml"), 'w') as f:
            f.write(yaml.dump(metadict, default_flow_style=False))

    refnamediv = root.find('./refnamediv')
    bookinfo = root.find('./bookinfo')
    md_content = ''
    if bookinfo is not None:
        sect1 = etree.Element('sect1')
        for elem in bookinfo:
            sect1.append(deepcopy(elem))
        root.replace(bookinfo, sect1)
    elif refnamediv is not None:
        root.remove(refnamediv)
        refname = refnamediv.find('./refname')
        if refname is not None:
            md_content += '# %s\n\n' % "".join(
                [x for x in refname.itertext()])
        refpurpose = refnamediv.find('./refpurpose')
        if refpurpose is not None:
            md_content += '*%s*\n' % "".join(
                [x for x in refpurpose.itertext()])

    if standalones:
        dump_gi_index(list(standalones), md_paths)

    md_content += db_to_md (etree.tostring(root))
    print "Writing", md_paths[new_name]
    with open (md_paths[new_name], 'w') as f:
        f.write (md_content)

    for new_name, filename in subpages.items():
        translate_docbook(filename, resolver, md_paths, new_name)

def parse_section_file(sections_path):
    here = os.path.dirname(__file__)
    trans_shscript_path = os.path.join(here, 'translate_sections.sh')
    cmd = [trans_shscript_path, sections_path, 'hotdoc-tmp-sections.txt']
    subprocess.check_call(cmd)
    sections_root = etree.parse('hotdoc-tmp-sections.txt').getroot()
    sections = {}
    for section in sections_root.findall ('.//SECTION'):
        sections[unicode(section.find('FILE').text)] = section

    os.unlink('hotdoc-tmp-sections.txt')
    return sections

def get_section_symbols(section):
    symbols = section.getchildren()[-1].tail.split("\n")
    return [s for s in symbols if s]

def write_symbols(section, name, symbols):
    opath = os.path.join(MD_OUTPUT_PATH, name + '.markdown')
    title = None
    if not os.path.exists(opath):
        title = section.find('./TITLE')

    print "writing", opath
    with open(opath, 'w+') as f:
        if title is not None:
            f.write("### %s\n\n" % title.text)
        for symbol in symbols:
            f.write('* [%s]()\n' % symbol)

def translate_sections(sections):
    for sname, snode in sections.items():
        symbols = get_section_symbols(snode)
        write_symbols(section, sname, symbols)

def dump_smart_page(npage, name, section):
    ssymbols = set(get_section_symbols(section))
    nsymbols = set(npage.symbol_names)
    extra = ssymbols - nsymbols
    if not extra:
        return

    write_symbols(section, name, extra)

def dump_smart_index(naive_pages, sections):
    for nname, npage in naive_pages.items():
        section = sections.pop(nname, None)
        if section is not None:
            dump_smart_page(npage, nname, section)

    for sname, snode in sections.items():
        write_symbols(snode, sname, get_section_symbols(snode))

if __name__=='__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--section-file', action='store',
        dest='section_file', help='The path to the gtk-doc "sections file"')
    parser.add_argument('--docbook-index', action='store',
        required=True, dest='docbook_index',
        help='The path to the docbook index')
    parser.add_argument('--conf-file', action='store',
        required=True, dest='conf_file',
        help='The path to a hotdoc.json file configured for'
             'parsing the C sources of the project')
    parser.add_argument('--extra-dtd-path', action='append',
        help='Path to an extra DTD if needed, can be specified multiple times',
        dest='extra_dtd_paths')

    args = parser.parse_args()
    # Ensure we build from scratch
    shutil.rmtree('hotdoc-private', ignore_errors=True)
    shutil.rmtree(MD_OUTPUT_PATH, ignore_errors=True)

    os.mkdir(MD_OUTPUT_PATH)

    require_path(args.conf_file)
    require_path(args.docbook_index)

    if args.section_file:
        require_path(args.section_file)

    resolver = DTDResolver(args.extra_dtd_paths)

    md_paths = {'gi-index': os.path.join(MD_OUTPUT_PATH, 'gi-index.markdown')}
    md_paths['index'] = os.path.join(MD_OUTPUT_PATH, 'index.markdown')
    translate_docbook(args.docbook_index, resolver, md_paths, 'index')

    sections = parse_section_file(args.section_file)
    #translate_sections(sections)

    args = ['run', '--conf-file', args.conf_file]
    monitor = DocRepoMonitor()
    monitor.build(args)

    dump_smart_index(monitor.naive_pages, sections)

    sys.exit(0)
